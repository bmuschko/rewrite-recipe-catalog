package com.yourorg.security;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.json.JSONArray;
import org.json.JSONObject;
import org.jspecify.annotations.Nullable;
import org.openrewrite.ExecutionContext;
import org.openrewrite.HttpSenderExecutionContextView;
import org.openrewrite.Option;
import org.openrewrite.ResourceUtils;
import org.openrewrite.ipc.http.HttpSender;
import org.openrewrite.java.dependencies.DependencyVulnerabilityCheckBase;
import org.openrewrite.java.dependencies.Vulnerability;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class ExternalCveDependencyVulnerabilityCheck extends DependencyVulnerabilityCheckBase {
    @Override
    public String getDisplayName() {
        return "Custom check for vulnerable dependencies";
    }

    @Override
    public String getDescription() {
        //language=markdown
        return "Supplements custom vulnerability checks for dependencies.";
    }

    @Option(displayName = "Scope",
            //language=markdown
            description = "Match dependencies with the specified scope. Default is `runtime`. " +
                    "An explanation of what each scope means can be found in the [Apache Maven documentation](https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Scope).",
            valid = {"compile", "test", "runtime", "provided"},
            example = "runtime",
            required = false)
    @Nullable
    String scope;

    @Option(displayName = "Override transitives",
            description = "When enabled transitive dependencies with vulnerabilities will have their versions overridden. " +
                    "By default only direct dependencies have their version numbers upgraded.",
            example = "false",
            required = false)
    @Nullable Boolean overrideTransitive;

    @Option(displayName = "Maximum upgrade delta",
            //language=markdown
            description = "The maximum difference to allow when suggesting a dependency version upgrade. " +
                    "Patch version upgrades are the default and safest option, as patch releases assert full backwards compatibility with no breaking changes. " +
                    "Minor version upgrades can introduce new features but do not _typically_ include breaking changes. " +
                    "Major version upgrades will typically require code changes above and beyond this recipe. ",
            valid = {"patch", "minor", "major"},
            example = "patch",
            required = false)
    @Nullable UpgradeDelta maximumUpgradeDelta;

    @Override
    public String getInstanceNameSuffix() {
        return "Last updated: " + ResourceUtils.getResourceAsString("last_updated") + ".";
    }

    @Override
    public List<Vulnerability> baselineVulnerabilities(ExecutionContext ctx) {
        List<Vulnerability> baselineVulnerabilities = new ArrayList<>();

        HttpSender httpSender = HttpSenderExecutionContextView.view(ctx).getHttpSender();
        try (HttpSender.Response response = httpSender.send(httpSender
                .newRequest("https://raw.githubusercontent.com/bmuschko/rewrite-recipe-catalog/refs/heads/main/src/test/resources/custom-cve.json")
                .withMethod(HttpSender.Method.GET)
                .withHeader("Accept", "application/json")
                .build())) {

            response.onSuccess(r -> {
                String responseBody = new String(r.getBodyAsBytes(), StandardCharsets.UTF_8);

                JSONObject root = new JSONObject(responseBody);
                JSONArray vulnerabilities = root.getJSONArray("vulnerabilities");
                vulnerabilities.forEach(vuln -> {
                    JSONObject vulnerabilityJson = (JSONObject) vuln;
                    String cve = vulnerabilityJson.getString("cve");
                    String summary = vulnerabilityJson.getString("summary");
                    String groupArtifact = vulnerabilityJson.getString("groupArtifact");
                    String introducedVersion = vulnerabilityJson.getString("introducedVersion");
                    String fixedVersion = vulnerabilityJson.optString("fixedVersion");
                    String lastAffectedVersion = vulnerabilityJson.optString("lastAffectedVersion");
                    String severity = vulnerabilityJson.getString("severity");
                    String cwes = vulnerabilityJson.optString("cwes");
                    baselineVulnerabilities.add(
                            new Vulnerability(cve, null, summary, groupArtifact, introducedVersion, fixedVersion, lastAffectedVersion,
                                    Vulnerability.Severity.valueOf(severity.toUpperCase()), cwes));
                });
            });

            response.onError(r -> {
                throw new RuntimeException("Failed to fetch vulnerabilities: " + r.getCode() + " " + new String(r.getBodyAsBytes()));
            });
        }

        return baselineVulnerabilities;
    }

    @Override
    public List<Vulnerability> supplementalVulnerabilities(ExecutionContext ctx) {
        return Collections.emptyList();
    }
}
